#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D colorBuffer;

// constants and uniforms

layout(location = 0) uniform vec2 uImageSize;
layout(location = 1) uniform int uNumSpheres;

float aspectRatio = uImageSize.x / uImageSize.y;

// structures
struct Material{
	vec4 _surfaceColor;
	float _ambient;
	float _diffuse;
	float _specular;
	float _shininess;
};

struct Sphere{
    Material _material;
    mat4 _transform;
    int _id;
    float _padding[7];
};

struct Camera{
    vec4 _position;
    vec4 _forward;
    vec4 _right;
    vec4 _up;
};

layout(std430, binding = 1) readonly buffer Spheres {
    Sphere spheres[];
};

layout(std430, binding = 2) readonly buffer CameraData {
    Camera camera;
};

struct Ray{
    vec4 origin;
    vec4 direction;
};
vec4 RayPositionAtT(Ray ray, float t);
Ray ApplyMatrixToRay(Ray r, mat4 m);

struct RayHit{
    bool _valid;
	float _t;
	vec4 _hitPoint;
	// vec4 _normal;
	uint _objectID;
};

RayHit IntersectRaySphere(Ray ray, Sphere sphere);


void main() {
	ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 screenSize = imageSize(colorBuffer);

	if(pixelPos.x >= screenSize.x || pixelPos.y >= screenSize.y) {
		return;
	}

	vec4 color = vec4(0.2, 0.2, 0.2, 1.0);

    Ray ray;
    ray.origin = camera._position;

    vec2 uv = ((pixelPos.xy / uImageSize.xy) * 2.0) - 1.0;

    ray.direction = vec4(uv.x * aspectRatio, uv.y, -1.0, 0.0);

    RayHit hits[32];// number of spheres
    for(int i = 0; i < uNumSpheres; i++) {
        hits[i] = IntersectRaySphere(ray, spheres[i]);
    }

    RayHit closestHit;
    closestHit._t = 10000.0;
    for(int i = 0; i < uNumSpheres; i++) {
        if(hits[i]._valid && (hits[i]._t < closestHit._t) && hits[i]._t < 10000.0) {
            closestHit = hits[i];
        }
    }
    if(closestHit._valid && closestHit._t < 900.0) {
        color = spheres[closestHit._objectID]._material._surfaceColor;
    }

	imageStore(colorBuffer, pixelPos, color);
}


vec4 RayPositionAtT(Ray ray, float t) {
    return vec4(ray.origin.xyz + (t * ray.direction.xyz), 1.0);
}

RayHit IntersectRaySphere(Ray ray, Sphere sphere) {
    RayHit hit;
    hit._valid = false;

    Ray transformedRay = ApplyMatrixToRay(ray, inverse(sphere._transform));
    vec4 oc = vec4(transformedRay.origin) - sphere._transform[3];
    float a = dot(transformedRay.direction.xyz, transformedRay.direction.xyz);
    float b = 2.0 * dot(oc.xyz, transformedRay.direction.xyz);
    float c = dot(oc.xyz, oc.xyz) - (1.0);
    float discriminant = (b * b) - (4.0 * (a * c));

    if (discriminant < 0.0){
        return hit; // no intersection
    }

    // Calculate the two intersection points
	float sqrtDiscriminant = sqrt(discriminant);
	float t1 = (-b - sqrtDiscriminant) / (2.0 * a);

    vec4 point1 = RayPositionAtT(transformedRay, t1);

    hit._t = t1;
    hit._hitPoint = point1;
    hit._valid = true;
    hit._objectID = sphere._id;
    return hit;
}

Ray ApplyMatrixToRay(Ray r, mat4 m) {
	// Apply the transformation matrix to the ray's origin and direction
	vec4 origin = r.origin;
	vec4 direction = r.direction;
	vec4 newOrigin = vec4(origin.x, origin.y, origin.z, origin.w) * m;
	vec4 newDirection = vec4(direction.x, direction.y, direction.z, direction.w) * m;

	return Ray(vec4(newOrigin), vec4(newDirection));
}